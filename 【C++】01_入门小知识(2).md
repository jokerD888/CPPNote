# 【C++】01_入门小知识（2）

## 07.引用

### 7.1引用的概念

引用不是新定义一个变量，而是给**已存在变量**取了一个**别名**，编译器**不会为引用变量开辟内存空间**，它和它引用的变量共用同一块内存空间。

比如，你可能有个小名，或者绰号，但都指的是你本身，引用与此意思类似。

- 语法：类型& 引用变量名(对象名) = 引用实体；

```cpp
void TestRef()
{
     int a = 10;
     int& ra = a;//<====定义引用类型

     printf("%p\n", &a);
     printf("%p\n", &ra);
}

```

### 7.2 引用特性

这些特性都是要注意的🗣：

1. 引用在定义时必须初始化；
2. 一个变量可以有多个引用，但引用一旦引用一个实体，再不能引用其他实体。

```cpp
void TestRef()
{
     int a = 10;
     // int& ra; // 编译时会出错,注意事项1
     int& ra = a;
     int& rra = a;
     int b=20;
     //ra=b;//编译时会出错，引用一旦引用一个实体，再不能引用其他实体
     printf("%p %p %p\n", &a, &ra, &rra);
}

```

### 7.3 常引用

- 当引用常量时，需要添加**const**修饰。

```cpp
void TestConstRef()
{
     const int a = 10;
     //int& ra = a; // 该语句编译时会出错，a为常量
     const int& ra = a;
     // int& b = 10; // 该语句编译时会出错，b为常量
     const int& b = 10;
     double d = 12.34;
     //int& rd = d; // 该语句编译时会出错，类型不同
     const int& rd = d;
}

```

### 7.4使用场景

```cpp
//1.做参数
void Swap(int& left, int& right)
{
     int temp = left;
     left = right;
     right = temp;
}
//2.做返回值
int& Count()
{
     static int n = 0；
     n++;
     // ...
     return n;
}

//注意：如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回。
int& Add(int a, int b)
{
     int c = a + b;
     return c;
}
int main()
{
     int& ret = Add(1, 2);
     Add(3, 4);
     cout << "Add(1, 2) is :"<< ret <<endl;	//输出7，而不是3
     return 0;
}

```

### 7.5  引用和指针的区别

- 在语法概念上引用就是一个别名，**没有独立空间**，**和其引用实体共用**同一块空间。
- 但在**底层实现上**实际是有空间的，因为引用是按照**指针**方式来实现的。

```cpp
int main()
{
     int a = 10;
     int& ra = a;

     cout<<"&a = "<<&a<<endl;
     cout<<"&ra = "<<&ra<<endl;
     return 0;
}

```

- 引用和指针比较

  ```cpp
  //两者十分相同的操作
  int main()
  {
       int a = 10;
  
       int& ra = a;
       ra = 20;
  
       int* pa = &a;
       *pa = 20;
  
       return 0;
  }
  ```

  1. 引用在定义时必须初始化，指针没有要求；
  2.  引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型 实体；
  3. 没有NULL引用，但有NULL指针；
  4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占 4个字节)；
  5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小；
  6. 有多级指针，但是没有多级引用；
  7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理；
  8. 引用比指针使用起来相对更安全。

  

## 08.内联函数

### 8.1 内联函数的概念

- 以**inline**修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方**展开**，**没有函数压栈的开销**， 内联函数**提升程序运行的效率**。

### 8.2 特性

- inline是一种**以空间换时间**的做法，省去调用函数额开销。所以**代码很长**或者有**循环/递归**的函数**不适宜使用作为内联函数**。

- **inline对于编译器而言只是一个建议**，编译器会自动优化，如果定义为inline的函数体内有循环/递归等，编译器优化时会**忽略掉内联**。

- . inline**不建议声明和定义分离**，分离会导致**链接错误**。因为inline**被展开**，就**没有函数地址**了，链接就会找不到。

  ```cpp
  // F.h
  #include <iostream>
  using namespace std;
  inline void f(int i);
  // F.cpp
  #include "F.h"
  void f(int i)
  {
       cout << i << endl;
  }
  // main.cpp
  #include "F.h"
  int main()
  {
       f(10);
       return 0;
  }
  // 链接错误：main.obj : error LNK2019: 无法解析的外部符号 "void __cdecl f(int)" (?f@@YAXH@Z)，该符号在函数 _main 中被引用
  ```


### 8.3内敛函数与宏

- 宏的优点

  1. 增强代码的复用性；
  2. 提高性能。

- 宏的缺点

  1. 不方便调试宏（因为预编译阶段进行了替换）；
  2. 导致代码可读性差，可维护性差，容易误用；
  3. 没有类型安全的检查 。

  因此根据宏的缺点，有两个操作可以替代宏：

  - 常量定义就换用const 
  - 函数定义就换用内联函数

## 09.auto关键字(C++11)

### 9.1auto

- 在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量。
- C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型 指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。

比如：**简单的识别变量类型**：

```cpp
int TestAuto()
{
     return 10;
}
int main()
{
     int a = 10;
     auto b = a;
     auto c = 'a';
     auto d = TestAuto();

     cout << typeid(b).name() << endl;
     cout << typeid(c).name() << endl;
     cout << typeid(d).name() << endl;

     //auto e; 无法通过编译，使用auto定义变量时必须对其进行初始化
     return 0;
}

```

这还不足以体现auto的强大，但是当类型名过长时, auto的作用就发挥出来了。

注意🗣：使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类 型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为 变量实际的类型。

### 9.2auto的使用事项

1.  auto不能作为函数的参数,否则会编译失败;

2. auto不能直接用来声明数组；

   ```cpp
   void TestAuto()
   {
        int a[] = {1,2,3};
        auto b[] = {4，5，6};
   }
   ```

3. 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法;

4. auto在实际中最常见的优势用法就是**C++11**提供的**新式for循环**，还有**lambda表达式**等进行配合使用。

5. 用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&;

   ```cpp
   int main()
   {
        int x = 10;
        auto a = &x;
        auto* b = &x;
        auto& c = x;
        cout << typeid(a).name() << endl;
        cout << typeid(b).name() << endl;
        cout << typeid(c).name() << endl;
        *a = 20;
        *b = 30;
        c = 40;
        return 0;
   }
   
   ```

6. 当在**同一行声明多个变量时**，这些变量必须是**相同的类型**，否则编译器将会报错，因为编译器实际**只对第一个类型进行推导**，然后用推导出来的类型**定义其他变量**。

   ```cpp
   void TestAuto()
   {
        auto a = 1, b = 2;
        auto c = 3, d = 4.0; // 该行代码会编译失败，因为c和d的初始化表达式类型不同
   }
   
   ```

## 10. 基于范围的for循环(C++11)

### 	10.1 范围for的语法

- 如果在C++98中如果要遍历一个数组，大概就是for( ; ; ),这样用for循环遍历。

- 但对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此C++11中 引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量， 第二部分则表示被迭代的范围。

  ```cpp
  void TestFor()
  {
       int array[] = { 1, 2, 3, 4, 5 };
       for(auto& e : array)
       e *= 2;
  
       for(auto e : array)
       cout << e << " ";
  
   return 0;
  }
  ```

  注意🗣：与普通循环类似，可以用**continue**来结束本次循环，也可以用**break**来跳出整个循环。

### 10.2使用条件

- for循环迭代的范围必须是确定的；

  对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围。

  ```cpp
  void TestFor(int array[])	//错误，因为for的范围不确定。
  {
       for(auto& e : array)
       cout<< e <<endl;
  }
  
  ```

- 迭代的**对象**要实现++和==的操作。

  ​	关于对象和迭代器以及重写操作符的问题，往后会进行详细介绍，现在了解即可。

## 11. 指针空值nullptr(C++11)

### 11.1 C++98中的指针空值

- 在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的 错误，比如未初始化的指针。如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：

  ```cpp
  void TestPtr()
  {
       int* p1 = NULL;
       int* p2 = 0;
   // ……
  }
  
  ```

- NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：

  ```cpp
  #ifndef NULL
  #ifdef __cplusplus
  #define NULL 0
  #else
  #define NULL ((void *)0)
  #endif
  #endif
  ```

- 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在 使用空值的指针时，都不可避免的会遇到一些麻烦,如：

  ​	

  ```cpp
  void f(int)
  {
       cout<<"f(int)"<<endl;
  }
  void f(int*)
  {
       cout<<"f(int*)"<<endl;
  }
  int main()
  {
       f(0);
       f(NULL);
       f((int*)NULL);
       return 0;
  }
  //程序本意是想通过f(NULL)调用指针版本的f(int*)函数，但是由于NULL被定义成0，因此与程序的初衷相悖。
  //在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下
  //将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0。
  
  
  ```

### 11.2注意事项

1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。
2. . 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同
3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。



